# SynOSX FloatLog 设计意图（冻结版）

> 本文用于**冻结并统一** SynOSX 网站中「浮动运行时日志窗（FloatLog）」的设计目标、交互逻辑与系统边界。
>
> 目的不是“实现一个 UI”，而是**定义一个运行时治理组件的制度行为**，避免后续反复返工或设计漂移。

---

## 一、组件定位（What it is）

**FloatLog = 治理运行时的可视化窗口**

* 它不是 toast
* 不是 drawer
* 不是调试面板
* 更不是一个「点一下才出现的小按钮」

而是：

> **系统运行时（Audit / Replay / Runtime）的“实时可观察器”**

它代表：

* 系统正在运行
* 治理正在发生
* 行为正在被记录

这是一个**长期存在的运行时窗口**，而非临时提示。

---

## 二、默认状态（Default State）

### ✅ 默认必须是：**OPEN（展开态）**

页面加载后：

* 浮动日志窗 **直接可见**
* 内容区域存在
* 用户不需要“先点哪里”

❌ 禁止的默认状态：

* 只显示一个边缘小按钮（handle）
* 需要用户点击后才出现内容

**理由：**

> 治理不是可选功能，而是系统的常驻能力。

---

## 三、状态模型（State Machine）

FloatLog 只有 **三种合法状态**：

### 1️⃣ OPEN（展开态 · 默认）

* 显示完整日志内容
* 可拖动位置
* 右上角有明确的 **X 关闭按钮**

### 2️⃣ DOCKED（边缘收起态）

* 由用户**主动拖拽 / 推到屏幕边缘**触发
* 内容隐藏
* 仅显示一个小的 edge handle（边缘按钮）
* 用于“我暂时不想看，但不等于关闭”

### 3️⃣ CLOSED（关闭态）

* 由用户点击 **X** 触发
* 面板与 handle 均不显示
* 代表用户显式关闭本次会话中的运行时观察

---

## 四、Handle（边缘按钮）规则

### ❗ 核心原则

> **Handle 不是入口，而是“收起后的残影”**

### 合法出现条件：

* 仅当状态 = `DOCKED`

### 明确禁止：

* 页面一加载就显示 handle
* 没有内容却只有 handle

---

## 五、交互原则（Interaction Rules）

### 1. 拖动（Drag）

* FloatLog 在 OPEN 状态下可自由拖动
* 拖到屏幕边缘 → 自动吸附并进入 DOCKED

### 2. 关闭（Close）

* 右上角 **X** 是强语义操作
* 含义：

  > “我不想再看这个运行时窗口了”

### 3. 再打开（Re-open）

* 仅当处于 DOCKED 状态
* 用户点击 handle → 恢复 OPEN

---

## 六、职责边界（Separation of Concerns）

### `sx.floatlog.js` 的职责

* 管理三态：`open / docked / closed`
* 处理拖动、吸附、关闭
* 控制 DOM 显隐与位置

**不负责：**

* 日志业务内容
* Audit / Replay 逻辑
* 页面跳转

---

### 页面 runtime（如 index.runtime.js）的职责

* 只做一件事：

```js
SXFloatLog.append(...)
```

* 不决定：

  * 默认是否显示
  * 在哪显示
  * 怎么拖

---

## 七、设计哲学（Why this matters）

这个 FloatLog 设计体现的是 SynOSX 的核心价值观：

* **治理不是事后补丁，而是运行时常态**
* **系统行为必须是可观察的**
* **用户有控制权，但不是被迫触发**

如果一个治理系统：

* 默认把“治理窗口”藏起来
* 只在点按钮时才出现

那它在语义上就已经输了。

---

## 八、冻结声明（Freeze Statement）

> 从此文档起：

* 默认展开
* 三态模型
* Handle 只属于 Docked

**任何偏离此行为的实现，视为设计违宪。**

---

（完）
